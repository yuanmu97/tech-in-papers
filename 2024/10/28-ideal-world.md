# 28-ideal-world
Source: ch2 Deﬁning Multi-Party Computation



> computational and statistical security parameters

* 计算安全参数用于表示：攻击者通过离线计算破解的难度，一般用 $k$ 表示

* 统计安全参数用于表示：攻击者在协议交互中破解的难度，一般用 $\sigma$ 表示

* 其含义是：攻击者仅有 $2^{-\sigma} + v(k)$ 的概率破解成功，其中 $v$ 称为 negligible function，其满足：
  * 对于任意 polynomial $p$ ： $v(n) < 1/p(n)$​

  * 即该函数比任意 polynomial 的反函数都更快地渐进于 0




> (t,n)-secret sharing

* 直观理解，秘密共享机制旨在将一个称为秘密的信息 s 分成 n 份 shares，使得结合任意 t-1 方的信息都无法暴露关于 s 的任何信息，而结合任意 t 方都可以完整还原出 s
  * 具体地，如何形式化“结合任意 t-1 方的信息都无法暴露关于 s 的任何信息”：
    * 考虑任意 k < t，任意两个秘密 a,b，任意 k 份 shares 组成的向量 $v=[v_1, v_2, ..., v_k]$ 我们有：
      * $Pr[v=Shr(a)|k] = Pr[v=Shr(b)|k]$
    * Shr 是 sharing 算法
    * 我的理解是，对任意两个秘密而言，无法区分其产生的 k 份 shares
  * 如何形式化“结合任意 t 方都可以完整还原出 s”：
    * $Pr[\forall k \geq t, Rec(s_{i1}, ..., s_{i,k})=s]=1$​
    * Rec 是 reconstruction 算法
    * 我的理解是，基于任意 t 方的信息，都能百分百保障重建出 s 
* 一般场景下，我们会关心 (n,n)-secret sharing，即参与的 n 方必须结合全部信息才能还原 s，缺少任意一方的信息都无法还原 s



> Real-ideal 机制

* 在考虑何时 protocol 是安全的时候，一个直观的想法是：列出全部违反安全性的情况
  * 例如，攻击者不应该能够学习另一方输入的某个谓词、攻击者不应该能够诱导诚实方产生不可能的输出、攻击者不应该能够使其输入依赖于诚实方的输入。
* 但是，这种方法繁琐且容易出错，而且无法判断所列的情况何时才算是完整的
* real-ideal 机制通过引入一个隐含了所有安全性保证的“理想世界” ideal world，并根据这个理想世界来定义安全性，从而完全避免了通过列出违反安全的情况
* 在理想世界中，我们假设额外存在一个完全受信赖的参与方 T，所有原本的参与方把数据发给 T，由 T 完成计算并将结果发送给相应的参与方
* 那何时我们称一个协议是安全的呢？即当一个攻击者在现实世界场景下，能够做到的任何影响，都可以在理想世界中也做到。
  * 即，从攻击者的视角来看，现实世界与理想世界的情况并没有什么区别。在真实时间里，攻击者能做到的影响并没有变多





